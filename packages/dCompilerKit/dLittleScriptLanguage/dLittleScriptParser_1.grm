/* Copyright (c) <2009> <Newton Game Dynamics>
* 
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
* 
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely
*/


/*
 *------------------------------------------------------------------
 *
 * This grammar only have one shift reduce conflict, 
 * which the standerd dangling else in if-then-else
 * and is is resolved in favor of shift as it is is the custon tradition for languages like C, C++, java and c#
 *
 *------------------------------------------------------------------
 */

%{
// Newton Little Scripting Language specification 1.0.0
// loosely based on a subset of Java and C sharp

#include "dLSCstdafx.h"
#include "dLittleScriptParser.h"
#include "dLittleScriptLexical.h"
#include "dLittleScriptCompiler.h"
%}


%union 
{
	class dUserVariable: public dDefualtUserVariable
	{
		public:
		dUserVariable () 
			:dDefualtUserVariable (), m_node(NULL)
		{
		}
		
		dUserVariable (dToken token, const char* const text, int scannerLine, int scannerIndex)
			:dDefualtUserVariable (token, text, scannerLine, scannerIndex)
			,m_node(NULL)
		{
		}
		class dDAG* m_node;
	};
}

/*
%token ABSTRACT
%token BYVALUE
%token CAST CATCH CONST 
%token EXTENDS
%token FINAL FINALLY  FUTURE
%token GENERIC GOTO
%token IMPLEMENTS  INNER INSTANCEOF  

%token NATIVE JNULL
%token OPERATOR OUTER
%token PRIVATE PROTECTED 
%token REST 
%token SUPER SYNCHRONIZED
%token THIS THROW THROWS TRANSIENT TRY
%token VAR  VOLATILE
%token LITERAL BOOLLIT
*/

// language supported Keywords
%token _BYTE
%token _INT
%token _SHORT
%token _LONG
%token _BOOLEAN 
%token _FLOAT
%token _DOUBLE
%token _VOID
%token _CLASS
%token _IMPORT
%token _PUBLIC
%token _STATIC
%token _PACKAGE
%token _INTERFACE
%token _IDENTIFIER
%token _OP_DIM


%token _IF
%token _ELSE
%token _SWITCH
%token _CASE
%token _DEFAULT
%token _BREAK
%token _CONTINUE
%token _DO
%token _FOR
%token _WHILE
%token _RETURN
%token _IDENTICAL
%token _DIFFERENT
%token _LESS_EQUAL 
%token _GREATHER_EQUAL
%token _SHIFT_RIGHT 
%token _SHIFT_LEFT
%token _LOGIC_OR 
%token _LOGIC_AND 

%token _NEW
%token _INTEGER_CONST

%token _OP_INC _OP_DEC
%token _ASS_MUL _ASS_DIV _ASS_MOD _ASS_ADD _ASS_SUB
%token _ASS_SHL _ASS_SHR _ASS_AND _ASS_XOR _ASS_OR



%right _ELSE
%right _IF
%right '=' _ASS_MUL _ASS_DIV _ASS_MOD _ASS_ADD _ASS_SUB _ASS_SHL _ASS_SHR _ASS_AND _ASS_XOR _ASS_OR
%right '?' ':'
%left _LOGIC_OR 
%left _LOGIC_AND 
%left '|'
%left '^'
%left '&'
%left _IDENTICAL _DIFFERENT
%left _LESS_EQUAL _GREATHER_EQUAL '<' '>' 
%left _SHIFT_RIGHT _SHIFT_LEFT
%left '+' '-'
%left '*' '/' '%'
%right _NEW
%right '~'
%right '!' 
%right _OP_INC _OP_DEC


%{
#define MyModule ((dScriptCompiler*) this)
%}

%start ScriptFile

%%


/*


LocalVariableDeclarationsAndStatements
	: LocalVariableDeclarationOrStatement
	| LocalVariableDeclarationsAndStatements LocalVariableDeclarationOrStatement
	;




ImportStatement
	: _IMPORT QualifiedName SemiColons							{MyModule->ImportClass ($2.m_data);} 
	| _IMPORT QualifiedName '.' '*' SemiColons					{MyModule->ImportAllClasses ($2.m_data);} 
	;




	
	
	

	
ConstructorName
	: _IDENTIFIER												{$$ = MyModule->AddClassContructor ($1.m_data);}
	;
	
QualifiedName
	: _IDENTIFIER												{$$ = $1;} 
	| QualifiedName '.' _IDENTIFIER								{$$ = $1; $$.m_data = $1.m_data + $2.m_data + $3.m_data;} 
	;


	








ClassConstructorDeclaration
	: ConstructorName FunctionParameters FunctionBody			{$$ = MyModule->FunctionAddBodyBlock($3);}
	;




	
VariableInitializer
	: Expression													{$$ = $1;} 
	| '{' '}'														{_ASSERTE (0);}
	| '{' ArrayInitializers '}'										{_ASSERTE (0);}
	;



VariableDeclarator
	: DeclaratorName												{$$ = MyModule->NewLocalVariableStatement ($1.m_data);}
	| DeclaratorName '=' VariableInitializer						{$$ = MyModule->NewLocalVariableStatement ($1.m_data, $3);}
	;


LocalVariableDeclarationStatement
	: TypeSpecifier VariableDeclaratorList ';'						{$$ = MyModule->SetLocalVariablesType($1, $2);} 
	;
	
	
	

LocalVariableDeclarationOrStatement
	: LocalVariableDeclarationStatement								{$$ = MyModule->AddLocalVariableToCurrentBlock($1);}
	| Statement														{$$ = MyModule->AddStatementToCurrentBlock($1);}
	;	

	
ArgumentList
	: Expression													{$$ = $1;}
	| ArgumentList ',' Expression									{$$ = MyModule->ConcatenateParametersExpressions($1, $3);}
	;

FunctionCall
	: QualifiedName '(' ')'											{$$ = MyModule->NewExpressionFunctionCall ($1.m_data, dUserVariable());}
	| QualifiedName '(' ArgumentList ')'							{$$ = MyModule->NewExpressionFunctionCall ($1.m_data, $3);}
	;


<<<<<<< .mine
=======
DimemsionExpr
	: '[' Expression ']'											{$$ = MyModule->NewDimensionNode($2);} 
	;

>>>>>>> .r3205
DimemsionExprList
	: DimemsionExpr													{$$ = $1;}
	| DimemsionExprList DimemsionExpr								{_ASSERTE(0);}
	;
	


ExpressionNew
	: _NEW TypeName DimemsionExprList								{$$ = MyModule->NewExpressionOperatorNew ($2.m_data, $3);}
//	| _NEW TypeName 
//  | _NEW TypeName ArrayOperator
//	| _NEW TypeName '(' ArgumentList ')'
//	| _NEW TypeName '('              ')'
	;
	
ExpressionVariable
	: DeclaratorName												{$$ = MyModule->NewExpressionNodeVariable ($1.m_data);}
	| DeclaratorName DimemsionExpr									{$$ = MyModule->NewExpressionNodeVariable ($1.m_data, $2);}
	;	
	

Expression
	: _INTEGER_CONST												{$$ = MyModule->NewExpressionNodeConstant($1);} 
	| ExpressionVariable '=' Expression								{$$ = MyModule->NewExpresionNodeAssigment ($1, $3);} 
	| ExpressionVariable _ASS_ADD Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_SUB Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_MUL Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_DIV Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_MOD Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_SHL Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_SHR Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_AND Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_XOR Expression						{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| ExpressionVariable _ASS_OR Expression							{$$ = MyModule->NewExpresionNodeAssigment ($1, $2, $3);} 
	| Expression '+' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| Expression '-' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| Expression '*' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| Expression '/' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| Expression '%' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);}
	| Expression '>' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| Expression '<' Expression										{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);} 
	| '+' Expression %prec '~'										{$$ = $2;}
	| '-' Expression %prec '~'										{dUserVariable tmp; tmp.m_token = _INTEGER_CONST; tmp.m_data = "0"; tmp = MyModule->NewExpressionNodeConstant (tmp); $$ = MyModule->NewExpressionNodeBinaryOperator (tmp, $1, $2);}
	| Expression _OP_INC											{$$ = MyModule->NewExpresionNodePrefixPostfixOperator ($1, false, true);}
	| Expression _OP_DEC											{$$ = MyModule->NewExpresionNodePrefixPostfixOperator ($1, false, false);}
	| _OP_INC Expression 											{$$ = MyModule->NewExpresionNodePrefixPostfixOperator ($2, true, true);}
	| _OP_DEC Expression 											{$$ = MyModule->NewExpresionNodePrefixPostfixOperator ($2, true, false);}
	| Expression _IDENTICAL Expression								{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);}
	| Expression _DIFFERENT Expression								{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);}
	| Expression _LESS_EQUAL Expression								{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);}
	| Expression _GREATHER_EQUAL Expression							{$$ = MyModule->NewExpressionNodeBinaryOperator ($1, $2, $3);}
	| Expression _LOGIC_OR Expression								{$$ = MyModule->NewExpressionNodeLogiOperator ($1, $2, $3);}
	| Expression _LOGIC_AND Expression								{$$ = MyModule->NewExpressionNodeLogiOperator ($1, $2, $3);}
	| ExpressionNew													{$$ = $1;}
	| ExpressionVariable											{$$ = $1;}
	| FunctionCall													{$$ = $1;}
	| '(' Expression ')'											{$$ = $2;}	
	;


ExpressionStatement
	: Expression ';'												{$$ = $1;}
	;
	
	
ConditionalStatementBody
	: Statement														{$$ = $1;}		
	| LocalVariableDeclarationStatement								{$$ = $1;}
	;
	
ConditionalStatement
	: _IF '(' Expression ')' ConditionalStatementBody									{$$ = MyModule->NewIFStatement($3, $5, dUserVariable());}
	| _IF '(' Expression ')' ConditionalStatementBody _ELSE ConditionalStatementBody	{$$ = MyModule->NewIFStatement($3, $5, $7);}
	;

ReturnStatement
	: _RETURN ';'													{$$ = MyModule->NewReturnStatement(dUserVariable());}
	| _RETURN Expression ';'										{$$ = MyModule->NewReturnStatement($2);}
	;


ForInitType
	: PrimitiveType													{$$ = MyModule->EmitTypeNode ($1);}
	;

ForInitExpression
	: Expression													{$$ = MyModule->NewForAssigmentExpresion (dUserVariable(), $1);}
	| ForInitType Expression										{$$ = MyModule->NewForAssigmentExpresion ($1, $2);}
	;
	
ForInit
	: ForInitExpression												{$$ = $1;}
	| ForInit ',' ForInitExpression									{_ASSERTE (0);}
	;
	
ForStep
	: Expression													{$$ = $1;}
//	| ForStep ',' Expression										{_ASSERTE (0); there is a bug here with the parcel generator}
	;
	
JumpStatement
	: _BREAK ';'													{$$ = MyModule->NewBreakStatement();}
	| _CONTINUE ';'													{$$ = MyModule->NewContinueStatement();}
	;

CaseStatementList
	: Statement														{$$ = $1;}
	| CaseStatementList Statement									{$$ = MyModule->ConcatenateCaseStatement ($1, $2);}
	;

Case
	: _CASE _INTEGER_CONST ':' CaseStatementList					{$$ = MyModule->NewCaseStatement ($2.m_data, $4);}
	| _DEFAULT ':' CaseStatementList								{$$ = MyModule->NewCaseStatement ("default", $3);}
	;
	
CaseList 
	: Case															{$$ = $1;}
	| CaseList Case													{$$ = MyModule->ConcatenateCaseBlocks ($1, $2);}
	;

SwitchStatement
	: _SWITCH '(' Expression ')' '{' CaseList '}'					{$$ = MyModule->NewSwitchStatement($3, $6);}
	;

IterationStatement
	: _FOR '(' ForInit ';' Expression ';' ForStep ')' Statement		{$$ = MyModule->NewForStatement($3, $5, $7, $9);}
	| _FOR '(' ForInit ';' Expression ';'         ')' Statement		{$$ = MyModule->NewForStatement($3, $5, dUserVariable(), $8);}
	| _FOR '('         ';' Expression ';' ForStep ')' Statement		{$$ = MyModule->NewForStatement(dUserVariable(), $4, $6, $8);}
	| _FOR '('         ';' Expression ';'         ')' Statement		{$$ = MyModule->NewForStatement(dUserVariable(), $4, dUserVariable(), $7);}
	| _FOR '(' ForInit ';'			  ';' ForStep ')' Statement		{$$ = MyModule->NewForStatement($3, dUserVariable(), $6, $7);}
	| _FOR '(' ForInit ';'			  ';'         ')' Statement		{$$ = MyModule->NewForStatement($3, dUserVariable(), dUserVariable(), $7);}
	| _FOR '('         ';'			  ';' ForStep ')' Statement		{$$ = MyModule->NewForStatement($3, dUserVariable(), $5, $7);}
	| _FOR '('         ';'			  ';'         ')' Statement		{$$ = MyModule->NewForStatement(dUserVariable(), dUserVariable(), dUserVariable(), $6);}
	| _DO Statement _WHILE '(' Expression ')' ';'					{$$ = MyModule->NewDoStatement($5, $2);}
	| _WHILE '(' Expression ')' Statement							{$$ = MyModule->NewWhileStatement($3, $5);}
	;

EmptyStatement
	: ';'															{$$ = MyModule->NewEmptyStatement();}
	;

Statement
	: EmptyStatement												{$$ = $1;}
	| Block															{$$ = $1;}
	| ReturnStatement 												{$$ = $1;}	
	| ExpressionStatement 											{$$ = $1;}
	| ConditionalStatement											{$$ = $1;}
	| IterationStatement											{$$ = $1;}
	| JumpStatement													{$$ = $1;}		
	| SwitchStatement												{$$ = $1;}
	;

PackageStatement
	: _PACKAGE QualifiedName SemiColons				{ MyModule->OpenPackage ($2.m_data);} 
	;

ImportStatements
	: ImportStatement
	| ImportStatements ImportStatement
	;
*/

ScriptFile
	: ProgramFile
	;

ProgramFile
	:                                   
	|                                   ClassDeclarationList
//	|                  ImportStatements
//	|                  ImportStatements ClassDeclarationList
//	| PackageStatement
//	| PackageStatement                  ClassDeclarationList	
//	| PackageStatement ImportStatements
//	| PackageStatement ImportStatements ClassDeclarationList
	;
	
ClassDeclarationList
	: ClassDeclarationAndOrSemiColon
	| ClassDeclarationList ClassDeclarationAndOrSemiColon
	;	

SemiColons
	: ';'				
	| SemiColons ';'	
	;

ClassDeclarationAndOrSemiColon
	: ClassDeclaration
	| ClassDeclaration SemiColons
	;


Modifier
	: _PUBLIC													{$$ = $1;} 
	| _STATIC													{$$ = $1;} 
//	| ABSTRACT													{$$ = $1;} 
//	| FINAL														{$$ = $1;} 
//	| PROTECTED													{$$ = $1;} 
//	| PRIVATE													{$$ = $1;} 
//	| TRANSIENT													{$$ = $1;} 
//	| VOLATILE													{$$ = $1;} 
//	| NATIVE													{$$ = $1;} 
//	| SYNCHRONIZED												{$$ = $1;} 	
	;

	
ClassWord
	: _CLASS													
//	| _INTERFACE												
	;	

Modifiers
	: Modifier													{$$ = $1;} 
	| Modifiers Modifier										{$$ = $1; $$.m_data = $1.m_data + ' ' + $2.m_data;} 
	;

ClassHeader
	:           ClassWord _IDENTIFIER							{$$ = MyModule->CreateClass ("private", $1.m_data, $2.m_data, "", "");} 
	| Modifiers ClassWord _IDENTIFIER							{$$ = MyModule->CreateClass ($1.m_data, $2.m_data, $3.m_data, "", "");} 
//	| Modifiers ClassWord _IDENTIFIER Extends Interfaces
//	| Modifiers ClassWord _IDENTIFIER Extends
//	| Modifiers ClassWord _IDENTIFIER		  Interfaces
//	|           ClassWord _IDENTIFIER Extends Interfaces
//	|           ClassWord _IDENTIFIER Extends
//	|           ClassWord _IDENTIFIER         Interfaces
	;
	




ArrayOperator
	: _OP_DIM														{$$ = MyModule->NewDimensionNode(dUserVariable());} 
	| ArrayOperator _OP_DIM											{$$ = MyModule->ConcatenateDimensionNode($1, MyModule->NewDimensionNode(dUserVariable()));} 
	;


TypeSpecifier
	: TypeName														{$$ = MyModule->EmitTypeNode ($1);}
	| TypeName ArrayOperator										{$$ = MyModule->EmitTypeNode ($1, $2);} 
	;

PrimitiveType
	; _VOID															{$$ = $1;} 
	| _BOOLEAN														{$$ = $1;} 
	| _BYTE															{$$ = $1;}
	| _SHORT														{$$ = $1;}
	| _INT															{$$ = $1;} 
	| _LONG															{$$ = $1;}
	| _FLOAT														{$$ = $1;}
	| _DOUBLE														{$$ = $1;}
	;


TypeName
	: PrimitiveType													{$$ = $1;} 
//	| QualifiedName													{$$ = $1;} 
	;



ClassVariableIdentifier
	: _IDENTIFIER													{$$ = MyModule->NewVariableStatement ($1.m_data);}
	;

ClassVariableIdentifierList
	: ClassVariableIdentifier										{$$ = $1;} 
	| ClassVariableIdentifierList ',' ClassVariableIdentifier		{$$ = MyModule->ConcatenateVariables($1, $3);} 
	;


ClassVariableDeclaration
	:           TypeSpecifier ClassVariableIdentifierList 			{$$ = MyModule->AddClassVariable (dUserVariable(), $1, $2);}
//	| Modifiers TypeSpecifier ClassVariableIdentifierList			{_ASSERTE (0); $$ = MyModule->AddClassVariable ($1, $2, $3);}
	;



ClassFieldDeclaration
	: ClassVariableDeclaration 
	| ClassFunctionDeclaration
//	| ClassConstructorDeclaration
//	| StaticInitializer
//	| NonStaticInitializer
//	| ClassDeclaration
	;

ClassFieldDeclarationAndOrSemiColon
    : ClassFieldDeclaration
    | ClassFieldDeclaration SemiColons
    ;


ClassFieldDeclarationList
	: ClassFieldDeclarationAndOrSemiColon
    | ClassFieldDeclarationList ClassFieldDeclarationAndOrSemiColon
	;

ClassDeclaration
	: ClassHeader '{' '}'											
	| ClassHeader '{' ClassFieldDeclarationList '}'							
	;


FunctionName
	:		    TypeSpecifier _IDENTIFIER							{$$ = MyModule->AddClassFunction ($1, $2.m_data, "");}	 
	| Modifiers TypeSpecifier _IDENTIFIER							{$$ = MyModule->AddClassFunction ($2, $3.m_data, $1.m_data);}	 
	;	


ClassFunctionDeclaration
	: FunctionName FunctionParameters FunctionBody					{$$ = MyModule->FunctionAddBodyBlock($3);}
	;


FunctionParameters
	: '(' ')'														{$$ = dUserVariable();}
	| '(' FunctionParameterList ')'									{$$ = $2;}
	; 

FunctionParameterList
	: Parameter														{$$ = MyModule->FunctionAddParameterNode ($1);}	
	| FunctionParameterList ',' Parameter							{$$ = MyModule->FunctionAddParameterNode ($3);}	
	;

Parameter
	: TypeSpecifier DeclaratorName									{$$ = MyModule->NewParameterNode ($1, $2.m_data);}
	;




FunctionBody
	: ';'															{_ASSERTE (0);}
	| Block															{$$ = $1;}
	;


BlockBegin
	: '{'															{$$ = MyModule->BeginScopeBlock ();} 
	;

Block
	: BlockBegin '}'												{$$ = MyModule->EndScopeBlock ($1);} 
//	| BlockBegin LocalVariableDeclarationsAndStatements '}'			{$$ = MyModule->EndScopeBlock ($1);}
	;


%%





